Spring容器的refresh()【创建以及刷新】
1.prepareRefresh();刷新前的预处理
	1) initPropertySources()初始化一些属性设置；子类自定义个性化的属性设置方法
	2) getEnvironment().validateRequiredProperties();检验属性的合法等
	3) this.earlyApplicationEvents = new LinkedHashSet<>();保存容器中的一些早期的事件
	
2.obtainFreshBeanFactory(); 获取BeanFactory
	1) refreshBeanFactory();刷新BeanFactory
		创建了一个this.beanFactory = new DefaultListableBeanFactory();
		设置id;
	2) getBeanFactory();返回GenericApplicationContext创建的BeanFactory对象
	3) 将创建的BeanFactory【DefaultListableBeanFactory】返回；
	
3.prepareBeanFactory(beanFactory);BeanFactory的欲准备工作（BeanFactory进行一些设置）
	1) 设置BeanFactory的类加载器,支持表达式解析器...
	2) 添加部分BeanPostProcessor【ApplicationContextAwareProcessor】
	3) 设置忽略的自动装配的接口EnvironmentAware,EmbeddedValueResolverAware,xxx;
	4) 注册可以解析的自动装配；我们能直接在任何组件中自动注入：
		BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext
	5) 添加BeanPostProcessor【ApplicationListenerDetector】
	6) 添加编译时的AspectJ
	7) 给BeanFactory中注册一些能用的组件：
		environment【ConfigurableEnvironment】,
		systemProperties【Map<String, Object>】,
		systemEnvironment【Map<String, Object>】

4.postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作
	1) 子类通过重写这个方法来BeanFactory创建并预准备完成以后做进一步的设置

============================== 以上是BeanFactory的创建以及预准备工作 =========================================
5.invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactory的BeanFactoryPostProcessors
	BeanFactoryPostProcessor:BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的；
	两个接口:BeanFactoryPostProcessor,BeanDefinitionRegistryPostProcessor
	1) BeanFactoryPostProcessor的方法
	   先执行BeanDefinitionRegistryPostProcessor
		1）获取所有的BeanDefinitionRegistryPostProcessor
		2） 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor,
			postProcessor.postProcessBeanDefinitionRegistry(registry);
		3) 在执行实现了Ordered顺序接口的 BeanDefinitionRegistryPostProcessor
		4) 最后执行没有实现任何优先级或顺序接口的BeanDefinitionRegistryPostProcessors
		
		在执行BeanFactoryPostProcessor的方法
		1) 获取所有的BeanFactoryPostProcessor
		2） 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor,
			postProcessor.postProcessBeanDefinitionRegistry();
		3) 在执行实现了Ordered顺序接口的 BeanDefinitionRegistryPostProcessor
			postProcessor.postProcessBeanDefinitionRegistry();
		4) 最后执行没有实现任何优先级或顺序接口的BeanDefinitionRegistryPostProcessors
			postProcessor.postProcessBeanDefinitionRegistry();

6.registerBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）【intercept bean creation.】
	不同接口类型的BeanPostProcessor；在bean创建前后的执行时机是不一样的。
	BeanPostProcessor,
	DestructionAwareBeanPostProcessor,
	InstantiationAwareBeanPostProcessor,
	SmartInstantiationAwareBeanPostProcessor,
	MergedBeanDefinitionPostProcessor 【internalPostProcessors】
	1) 获取所有的 BeanPostProcessor；后置处理器都默认可以通过PriorityOrdered,Ordered接口来指定执行优先级
	2）先注册PriorityOrdered优先级接口的BeanPostProcessor
	  把每一个BeanPostProcessor 添加到BeanFactory中
	  beanFactory.addBeanPostProcessor(postProcessor);
	3）再注册Ordered接口的
	4） 最后注册没有实现任何优先级接口的
	5） 最终注册MergedBeanDefinitionPostProcessor
	6) 注册一个ApplicationListenerDetector；来Bean创建完成后检查是否是ApplicationListener,如果是
		this.applicationContext.addApplicationListener((ApplicationListener<?>) bean);

7.initMessageSource();初始化MessageSource组件（做国际化功能，消息绑定，消息解析）
	1） 获取BeanFactory
	2) 查看容器中是否有id为messageSource的组件
		如果有赋值给messageSource属性，如果没有自己创建一个DelegatingMessageSource
		 MessageSource：取出国际化配置文件中的某个Key的值；能够获取区域信息
	3) 把创建好的MessageSource注册到容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource，
			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
			MessageSource.getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);